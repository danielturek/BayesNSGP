---
title: Test implementation of fullGP, NNGP, SGV in nimble
author: Mark Risser
date: 21 March 2019
output: html_document
---

\   

```{r, message = FALSE, warning = FALSE}
library(nimble)
library(coda)
library(StatMatch)
library(ggplot2)
library(gridExtra)
library(RColorBrewer)
nimbleOptions(verbose = TRUE)
source("../BayesNSGP/BayesNSGP/R/core.R")
source("../BayesNSGP/BayesNSGP/R/NNGP.R")
source("../BayesNSGP/BayesNSGP/R/SGV.R")

```

\   

### Data

We'll use some simulated data for now:

```{r}
# Stationary/isotropic
N <- 100
M <- 15^2
k <- 15
set.seed(12)
locs <- matrix(runif(2*N), ncol = 2)
alpha_vec <- rep(log(sqrt(1)), N) # Log process SD
delta_vec <- rep(log(sqrt(0.05)), N) # Log nugget SD
Sigma11_vec <- rep(0.4, N) # Kernel matrix element 1,1
Sigma22_vec <- rep(0.4, N) # Kernel matrix element 2,2
Sigma12_vec <- rep(0, N) # Kernel matrix element 1,2
mu_vec <- rep(0, N) # Mean
nu <- 0.5 # Smoothness
dist_list <- nsDist(locs)

Cor_mat <- nsCorr( dist1_sq = dist_list$dist1_sq, dist2_sq = dist_list$dist2_sq, 
        dist12 = dist_list$dist12, Sigma11 = Sigma11_vec, 
        Sigma22 = Sigma22_vec, Sigma12 = Sigma12_vec, nu = nu )
Cov_mat <- diag(exp(alpha_vec)) %*% Cor_mat %*% diag(exp(alpha_vec))
D_mat <- diag(exp(delta_vec)^2) 
set.seed(110)
z <- as.numeric(mu_vec + t(chol(Cov_mat + D_mat)) %*% rnorm(N))
z_unord <- z

predCoords <- as.matrix(expand.grid(seq(0,1,length = sqrt(M)),seq(0,1,length = sqrt(M))))

```

Now, set up the constants list for each likelihood:

```{r }
# FullGP 
dist_fullGP <- nsDist(locs)
constants_fullGP <- list( dist1_sq = dist_fullGP$dist1_sq, dist2_sq = dist_fullGP$dist2_sq, 
                          dist12 = dist_fullGP$dist12, nu = 0.5, N = N, Sigma_HP1 = 2 )

# NNGP
nID_NNGP <- determineNeighbors(locs, k)
dist_NNGP <- nsDist3d(locs, nID_NNGP)
constants_NNGP <- list( dist1_3d = dist_NNGP$dist1_3d, dist2_3d = dist_NNGP$dist2_3d, 
                        dist12_3d = dist_NNGP$dist12_3d, nu = 0.5, N = N, k = k, nID = nID_NNGP, 
                        Sigma_HP1 = 2 )

# SGV
SGV_setup <- sgvSetup(locs = locs, k = k, seed = 3)
nID_SGV <- SGV_setup$nID_ord
dist_SGV <- nsDist3d(locs[SGV_setup$ord,], nID_SGV)
constants_SGV <- list( dist1_3d = dist_SGV$dist1_3d, dist2_3d = dist_SGV$dist2_3d, 
                       dist12_3d = dist_SGV$dist12_3d, num_NZ = 3*N + k*N - (k*(k+1)/2),
                       nu = 0.5, N = N, k = k, nID = nID_SGV, cond_on_y = SGV_setup$condition_on_y_ord, 
                       Sigma_HP1 = 2 )

niter <- 4000
strt.kp <- 3001
```

\    

### Full GP model

First, we'll use the Full GP likelihood.

```{r, eval=FALSE}
# Defaults: tau_model = "constant", sigma_model = "constant", Sigma_model = "constant", mu_model = "constant"
Rmodel_fullGP <- nsgpModel( likelihood = "fullGP", constants = constants_fullGP, z = z )
compl_model_fullGP <- compileNimble( Rmodel_fullGP )
conf_model_fullGP <- configureMCMC( Rmodel_fullGP )
nim_mcmc_fullGP <- buildMCMC(conf_model_fullGP)
nim_Cmcmc_fullGP <- compileNimble(nim_mcmc_fullGP, project = Rmodel_fullGP)

prt <- proc.time()
nim_Cmcmc_fullGP$run(niter)
fullGP.tm <- proc.time() - prt
postSamp_fullGP <- as.matrix(nim_Cmcmc_fullGP$mvSamples)[strt.kp:niter,]

# Prediction
prt <- proc.time()
postSamp_pred_fullGP <- nsgpPredict( Rmodel_fullGP, postSamp_fullGP, locs, predCoords )
fullGP.pred.tm <- proc.time() - prt

# system.time(samples <- nimbleMCMC(model = Rmodel, niter = niter, progressBar = FALSE, setSeed = TRUE))
samplesList <- list(fullGP = postSamp_fullGP)
predSamplesList <- list(fullGP = postSamp_pred_fullGP)
```

\   

### NNGP

Next, we'll use the NNGP likelihood approximation, using $k=15$ nearest neighbors.

```{r, eval=FALSE}
# Defaults: tau_model = "constant", sigma_model = "constant", Sigma_model = "constant", mu_model = "constant"
Rmodel_NNGP <- nsgpModel( likelihood = "NNGP", constants = constants_NNGP, z = z )
compl_model_NNGP <- compileNimble( Rmodel_NNGP )
conf_model_NNGP <- configureMCMC( Rmodel_NNGP )
nim_mcmc_NNGP <- buildMCMC(conf_model_NNGP)
nim_Cmcmc_NNGP <- compileNimble(nim_mcmc_NNGP, project = Rmodel_NNGP)

prt <- proc.time()
nim_Cmcmc_NNGP$run(niter)
NNGP.tm <- proc.time() - prt
postSamp_NNGP <- as.matrix(nim_Cmcmc_NNGP$mvSamples)[strt.kp:niter,]

# Prediction
prt <- proc.time()
postSamp_pred_NNGP <- nsgpPredict( Rmodel_NNGP, postSamp_NNGP, locs, predCoords )
NNGP.pred.tm <- proc.time() - prt

samplesList$NNGP <- postSamp_NNGP
predSamplesList$NNGP <- postSamp_pred_NNGP
```

### SGV

Finally, we'll use the SGV likelihood approximation, again using $k=15$ nearest neighbors.

```{r, eval=FALSE}
# Defaults: tau_model = "constant", sigma_model = "constant", Sigma_model = "constant", mu_model = "constant"
Rmodel_SGV <- nsgpModel( likelihood = "SGV", constants = constants_SGV, z = z_unord[SGV_setup$ord] )
compl_model_SGV <- compileNimble( Rmodel_SGV )
conf_model_SGV <- configureMCMC( Rmodel_SGV )
nim_mcmc_SGV <- buildMCMC(conf_model_SGV)
nim_Cmcmc_SGV <- compileNimble(nim_mcmc_SGV, project = Rmodel_SGV)

prt <- proc.time()
nim_Cmcmc_SGV$run(niter)
SGV.tm <- proc.time() - prt
postSamp_SGV <- as.matrix(nim_Cmcmc_SGV$mvSamples)[strt.kp:niter,]

# Prediction
prt <- proc.time()
postSamp_pred_SGV <- nsgpPredict( Rmodel_SGV, postSamp_SGV, locs, predCoords, SGV_setup )
SGV.pred.tm <- proc.time() - prt

samplesList$SGV <- postSamp_SGV
predSamplesList$SGV <- postSamp_pred_SGV

timeList <- list(
  fullGP = fullGP.tm, fullGP.pred = fullGP.pred.tm,
  NNGP = NNGP.tm, NNGP.pred = NNGP.pred.tm,
  SGV = SGV.tm, SGV.pred = SGV.pred.tm
)
# save(samplesList, predSamplesList, timeList, file = "~/CASCADE_Projects/bayes_nsgp/test_implementation.RData")

```

\   

### Results

Check agreement between the fullGP, NNGP, and SGV likelihoods.

```{r, fig.height=6, fig.width=10, echo=FALSE }
load("~/CASCADE_Projects/bayes_nsgp/test_implementation.RData")

# chainsPlot(samplesList)
par(mfrow = c(2,3))
plot(samplesList[[1]][,"Sigma_coef1"], type = "l", xlab = "", ylab = "Anisotropy evalue1",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"Sigma_coef1"],
                    samplesList[[2]][,"Sigma_coef1"],
                    samplesList[[3]][,"Sigma_coef1"])))
lines(samplesList[[2]][,"Sigma_coef1"], col = 4)
lines(samplesList[[3]][,"Sigma_coef1"], col = 3)
abline(h = Sigma11_vec[1], col = 2)

plot(samplesList[[1]][,"Sigma_coef2"], type = "l", xlab = "", ylab = "Anisotropy evalue2",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"Sigma_coef2"],
                    samplesList[[2]][,"Sigma_coef2"],
                    samplesList[[3]][,"Sigma_coef2"])))
lines(samplesList[[2]][,"Sigma_coef2"], col = 4)
lines(samplesList[[3]][,"Sigma_coef2"], col = 3)
abline(h = Sigma22_vec[1], col = 2)

plot(samplesList[[1]][,"Sigma_coef3"], type = "l", xlab = "", ylab = "Anisotropy rotation",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"Sigma_coef3"],
                    samplesList[[2]][,"Sigma_coef3"],
                    samplesList[[3]][,"Sigma_coef3"])))
lines(samplesList[[2]][,"Sigma_coef3"], col = 4)
lines(samplesList[[3]][,"Sigma_coef3"], col = 3)
abline(h = Sigma12_vec[1], col = 2)

plot(samplesList[[1]][,"beta"], type = "l", xlab = "", ylab = "Mean",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"beta"],
                    samplesList[[2]][,"beta"],
                    samplesList[[3]][,"beta"])))
lines(samplesList[[2]][,"beta"], col = 4)
lines(samplesList[[3]][,"beta"], col = 3)
abline(h = mu_vec[1], col = 2)

plot(samplesList[[1]][,"delta"], type = "l", xlab = "", ylab = "Nugget variance",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"delta"],
                    samplesList[[2]][,"delta"],
                    samplesList[[3]][,"delta"])))
lines(samplesList[[2]][,"delta"], col = 4)
lines(samplesList[[3]][,"delta"], col = 3)
abline(h = exp(delta_vec[1]), col = 2)

plot(samplesList[[1]][,"alpha"], type = "l", xlab = "", ylab = "Spatial variance",
     main = "black = FullGP, blue = NNGP, green = SGV", 
     ylim = range(c(samplesList[[1]][,"alpha"],
                    samplesList[[2]][,"alpha"],
                    samplesList[[3]][,"alpha"])))
lines(samplesList[[2]][,"alpha"], col = 4)
lines(samplesList[[3]][,"alpha"], col = 3)
abline(h = exp(alpha_vec[1]), col = 2)
```

```{r, fig.height=3, fig.width=10, echo=FALSE}
grid.arrange(
    ggplot(data.frame(x = locs[,1], y = locs[,2], data = z), aes(x = x, y = y, color = data)) + labs(x = NULL, y = NULL) +
      geom_point() + scale_color_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], mean = colMeans(predSamplesList$fullGP$pred)), 
           aes(x = x, y = y, fill = mean)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], sd = apply(predSamplesList$fullGP$pred,2,sd)), 
           aes(x = x, y = y, fill = sd)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ncol = 3, top = "fullGP"
  )
grid.arrange(
    ggplot(data.frame(x = locs[,1], y = locs[,2], data = z), aes(x = x, y = y, color = data)) + labs(x = NULL, y = NULL) +
      geom_point() + scale_color_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], mean = colMeans(predSamplesList$NNGP$pred)), 
           aes(x = x, y = y, fill = mean)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], sd = apply(predSamplesList$NNGP$pred,2,sd)), 
           aes(x = x, y = y, fill = sd)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ncol = 3, top = "NNGP"
  )
grid.arrange(
    ggplot(data.frame(x = locs[,1], y = locs[,2], data = z), aes(x = x, y = y, color = data)) + labs(x = NULL, y = NULL) +
      geom_point() + scale_color_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], mean = colMeans(predSamplesList$SGV$pred)), 
           aes(x = x, y = y, fill = mean)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ggplot(data.frame(x = predCoords[,1], y = predCoords[,2], sd = apply(predSamplesList$SGV$pred,2,sd)), 
           aes(x = x, y = y, fill = sd)) + labs(x = NULL, y = NULL) +
      geom_tile() + scale_fill_gradientn(colors = brewer.pal(9, "Spectral")) + coord_fixed(ratio = 1),
    ncol = 3, top = "SGV"
  )

```

Compare compute times for the MCMC:

```{r, echo = FALSE}
data.frame(
  Method = c("fullGP","NNGP","SGV"),
  MCMC_time = c(timeList$fullGP[3], timeList$NNGP[3], timeList$SGV[3])
)
```

Compare compute times for the prediction:

```{r, echo = FALSE}
data.frame(
  Method = c("fullGP","NNGP","SGV"),
  Predict_time = c(timeList$fullGP.pred[3], timeList$NNGP.pred[3], timeList$SGV.pred[3])
)
```

Check effective sample size between the fullGP, NNGP, and SGV likelihoods.

```{r, echo = FALSE }
do.call('cbind', lapply(samplesList, function(x) apply(x, 2, effectiveSize)))
```


\   


\   

\   

\   

\    

\    

\   

\   

\   

\   

\    






