---
title: Application 1 annual precipitation in Colorado, 1981
author: Mark Risser
date: 10 April 2019
output: html_document
---

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(nimble)
library(coda)
library(StatMatch)
nimbleOptions(verbose = FALSE)
source("~/Documents/GitHub/BayesNSGP/BayesNSGP/R/core.R")
source("~/Documents/GitHub/BayesNSGP/BayesNSGP/R/NNGP.R")
source("~/Documents/GitHub/BayesNSGP/BayesNSGP/R/SGV.R")

library(ggplot2)
library(RColorBrewer)
library(gridExtra)
library(viridis)
library(fields)

# Shortcut function for plotting spatial data
plot_spat <- function( coords, param.hat, ttle.txt = NULL, col.lim = range(param.hat, na.rm = TRUE),
                        pt.size = 1.15, shp = 15, col.pal = brewer.pal(9, "RdYlBu")[9:1], brk_rd = 2,
                       plot.grid = FALSE, border.wd = 0.3 ){
  
  param.hat[!is.na(param.hat) & param.hat < col.lim[1]] <- col.lim[1]
  param.hat[!is.na(param.hat) & param.hat > col.lim[2]] <- col.lim[2]
  
  brks <- seq(from = col.lim[1], to = col.lim[2], length = 10)
  brks <- round(brks, brk_rd)
  
  Longitude <- coords[,1]
  Latitude <- coords[,2]
  
  if(!plot.grid){
    ggplot( data.frame(coords), aes( x = Longitude, y = Latitude, 
                                   color = cut(param.hat, brks, include.lowest = TRUE) ) ) +
      geom_polygon( data = map_data("state"), aes(x = long, y = lat, group = group),
                    color = NA, fill = "white", size = border.wd) +
    geom_point(size = pt.size, shape = shp, alpha = 1 ) +
      geom_polygon( data = map_data("state"), aes(x = long, y = lat, group = group),
                    color = "gray60", fill = NA, size = border.wd) +
    scale_color_manual( values = col.pal, name = "", drop = FALSE,
                        labels = c(paste("<", brks[2]),
                                   levels(cut(param.hat, brks, include.lowest = TRUE))[2:8],
                                   paste(">", brks[9]))) +
    ylab(NULL) + xlab(NULL) +
    coord_cartesian(xlim = range(Longitude), ylim = range(Latitude)) +
    guides(color = guide_legend( reverse = TRUE, override.aes = list(size=5) )) +
    ggtitle(ttle.txt) + theme_bw()

  } else{
      ggplot( data.frame(coords), aes( x = Longitude, y = Latitude, 
                                   fill = cut(param.hat, brks, include.lowest = TRUE) ) ) +
      geom_polygon( data = map_data("state"), aes(x = long, y = lat, group = group),
                    color = NA, fill = "white", size = border.wd) +
    geom_tile(na.rm = TRUE) +
      geom_polygon( data = map_data("state"), aes(x = long, y = lat, group = group),
                    color = "gray60", fill = NA, size = border.wd) +
    scale_fill_manual( values = col.pal, name = "", drop = FALSE,
                        labels = c(paste("<", brks[2]),
                                   levels(cut(param.hat, brks, include.lowest = TRUE))[2:8],
                                   paste(">", brks[9]))) +
    ylab(NULL) + xlab(NULL) +
    coord_cartesian(xlim = range(Longitude), ylim = range(Latitude)) +
    guides(fill = guide_legend( reverse = TRUE)) +
    ggtitle(ttle.txt) + theme_bw()

  }
}

library(ellipse)
plotEllip <- function(locs, kernel_array){
  mc.locations <- locs
  mc.kernels <- kernel_array
  K <- dim(mc.locations)[1]

  plot(ellipse(mc.kernels[, , 1], centre = mc.locations[1,], level = 0.75),
       type = "l", col = 2, asp = 1,
       xlab = "Longitude", ylab = "Latitude", ylim = c(36.5, 41.5), xlim = c(-110, -102))
  points(mc.locations[1,1], mc.locations[1,2], cex = 1, pch="+" ) 

  for (k in 2:K) {
    lines(ellipse(mc.kernels[, , k], centre = mc.locations[k,], level = 0.75), col = 2 )
    points(mc.locations[k,1], mc.locations[k,2], cex = 1, pch="+" ) 
  }
}

load("~/CASCADE_Projects/bayes_nsgp/BayesNSGP_analysis/analysis1.RData")

```

### Introduction

In this application, we reproduce an analysis of the precipitation data set used by Paciorek and Schervish (2006) from Colorado, a state in the western United States of America. The data used here consist of monthly precipitation recorded at each of approximately 400 weather stations in Colorado; we specifically analyze annual precipitation from 1981, as this year has the most stations (217) without missing monthly values. Annual precipitation totals are given in millimeters, and we analyze the log of total precipitation to make the Gaussian process assumption more appropriate.

The specific analysis is an illustration of two previous analyses of this data set: (1) the original analysis in Paciorek and Schervish (2006), and (2) the regression-based nonstationary covariance function from Risser and Calder (2015). The goal is to demonstrate how both of these models can be quickly implemented using the `BayesNSGP` package and NIMBLE.

First, load the data to be used in both analyses and create the constants needed for the NIMBLE functionality:

```{r, message = FALSE}
# Load data =====================================
COprecip <- read.csv("data/COprecip1981.csv")
coords <- as.matrix(COprecip[,c("Longitude", "Latitude")])
z <- COprecip$logPrecip
Xmat <- unname(lm(logPrecip ~ Zelevation*Zslope10, x = TRUE, data = COprecip)$x)
N <- nrow(COprecip)

# Distance matrices and constants ===============
dist_mats <- nsDist(coords)

# Load prediction grid: elevation and slope =====
COpredDF <- read.csv("data/COpredDF.csv")

```

Take a quick look at the data and covariates:

```{r, echo = FALSE, fig.height=6, fig.width=10, warning = FALSE}
grid.arrange(
  plot_spat(COpredDF[,1:2], COpredDF$elevation, brk_rd = 0, plot.grid = TRUE,
            ttle.txt = "Elevation (m)", col.pal = terrain.colors(9)),
  plot_spat(COpredDF[,1:2], COpredDF$slope, brk_rd = 0, plot.grid = TRUE, col.lim = c(-2200,2200),
            ttle.txt = "Slope (m/deg longitude, west to east)", col.pal = brewer.pal(9, "RdBu")),
  plot_spat(coords, z, pt.size = 1.25, shp = 16, brk_rd = 1, ttle.txt = "Annual precipitation, 1981 (log mm)",
            col.pal = viridis_pal(option = "viridis")(9)),
  nrow = 2
)

```


#### (1) Analysis of Paciorek and Schervish (2006)

In the original analysis, each of the mean, the nugget variance, and the spatial variance were modeled as an unknown constants, while the kernel matrix function was modeled using an approximation to a Gaussian process.

Note: the smoothness for the approximate GP is fixed to $\nu = 5$ (below, this is `Sigma_HP2`); in the original paper, the latent GP range was given a uniform prior on the log scale, with upper bound $\log 3.85$ and lower bound $\log 0.1$, while we use a $U(0, 3.85)$ prior on this parameter (below, this is `Sigma_HP3`); in the original paper they estimate the data-level smoothness with a $U(0.5, 30)$ prior while we fix this smoothness parameter at $\vu = 4$ (following the illustration in Section 3.1.2; below this is `nu = 4`).

```{r, eval = FALSE }
niter <- 20000
strt.kp <- 10001

# Set up the knot locations
x_min <- min(coords[,1])
x_max <- max(coords[,1])
y_min <- min(coords[,2])
y_max <- max(coords[,2])
N_knots <- 64
knot_coords <- expand.grid(
  lon = seq(from = x_min + 0.5*(x_max - x_min)/sqrt(N_knots), to = x_max - 0.5*(x_max - x_min)/sqrt(N_knots), 
            length = sqrt(N_knots)),
  lat = seq(from = y_min + 0.5*(y_max - y_min)/sqrt(N_knots), to = y_max - 0.5*(y_max - y_min)/sqrt(N_knots), 
            length = sqrt(N_knots))
)
dist_coords <- as.matrix(dist(coords, upper = T, diag = T))
Sigma_knot_dist <- as.matrix(dist(knot_coords, upper = T, diag = T))
Sigma_cross_dist <- mahalanobis.dist(coords, knot_coords, diag(2))

constants_PacScher <- list( 
  dist1_sq = dist_mats$dist1_sq, dist2_sq = dist_mats$dist2_sq, 
  dist12 = dist_mats$dist12, nu = 4, N = N,
  Sigma_HP1 = c(10,10), Sigma_HP2 = rep(5,2), Sigma_HP3 = rep(3.85,2), 
  Sigma_HP4 = c(10,20), Sigma_HP5 = 16,
  dist = dist_coords, Sigma_cross_dist = Sigma_cross_dist, Sigma_knot_dist = Sigma_knot_dist,
  p_Sigma = N_knots, mu_HP1 = 10 )

# Defaults: tau_model = "constant", sigma_model = "constant", mu_model = "constant"
Rmodel_PacScher <- nsgpModel( likelihood = "fullGP", constants = constants_PacScher, 
                              z = z, Sigma_model = "npApproxGP" )
compl_model_PacScher <- compileNimble( Rmodel_PacScher )
conf_model_PacScher <- configureMCMC( Rmodel_PacScher )
conf_model_PacScher$addMonitors(c("Sigma11", "Sigma22", "Sigma12"))
conf_model_PacScher$addMonitors(c("w1_Sigma", "w2_Sigma", "w3_Sigma"))
nim_mcmc_PacScher <- buildMCMC(conf_model_PacScher)
nim_Cmcmc_PacScher <- compileNimble(nim_mcmc_PacScher, project = Rmodel_PacScher)

prt <- proc.time()
nim_Cmcmc_PacScher$run(niter)
PacScher.tm <- proc.time() - prt
postSamp_PacScher <- as.matrix(nim_Cmcmc_PacScher$mvSamples)[strt.kp:niter,]

```

#### (2) Analysis of Risser and Calder (2015)

Using the regression-based methodology of Risser and Calder (2015), covariate information can be included in three parts of the nonstationary model: the mean function, the spatial variance function, and the kernel matrix function. Risser and Calder (2015) consider elevation as well as a covariate that describes change in elevation ("slope"), measured as a west-to-east gradient. Here, we reproduce the FNS-M2 implementation, which includes the main effects of elevation and slope, as well as their interaction, in each of the mean, variance, and kernel matrix functions. Following Risser and Calder (2015), elevation and slope measurements are standardized in order to put the coefficient estimates on a similar scale.

```{r, eval = FALSE }
niter <- 20000
strt.kp <- 10001

constants_RisserCalder <- list( dist1_sq = dist_mats$dist1_sq,  dist2_sq = dist_mats$dist2_sq, 
                                dist12 = dist_mats$dist12, nu = 0.5, N = N,
                                X_mu = Xmat, p_mu = ncol(Xmat), mu_HP1 = 10,
                                X_sigma = Xmat, p_sigma = ncol(Xmat), log_sigma_HP1 = 10,
                                X_Sigma = Xmat, p_Sigma = ncol(Xmat), Sigma_HP1 = c(10,10), 
                                Sigma_HP2 = c(2,2), Sigma_HP5 = 16)

# Defaults: tau_model = "constant"
Rmodel_RisserCalder <- nsgpModel( likelihood = "fullGP", constants = constants_RisserCalder, z = z,
                                  mu_model = "linReg", sigma_model = "logLinReg", Sigma_model = "covReg" )
compl_model_RisserCalder <- compileNimble( Rmodel_RisserCalder )
conf_model_RisserCalder <- configureMCMC( Rmodel_RisserCalder )
conf_model_RisserCalder$removeSamplers( c("psi11", "psi22", "rho") )
conf_model_RisserCalder$addSampler( target = c("psi11", "psi22", "rho"), type = "RW_block" )
nim_mcmc_RisserCalder <- buildMCMC(conf_model_RisserCalder)
nim_Cmcmc_RisserCalder <- compileNimble(nim_mcmc_RisserCalder, project = Rmodel_RisserCalder)

prt <- proc.time()
nim_Cmcmc_RisserCalder$run(niter)
RisserCalder.tm <- proc.time() - prt
postSamp_RisserCalder <- as.matrix(nim_Cmcmc_RisserCalder$mvSamples)[strt.kp:niter,]

# save(PacScher.tm, postSamp_PacScher, RisserCalder.tm, postSamp_RisserCalder, file = "~/CASCADE_Projects/bayes_nsgp/BayesNSGP_analysis/analysis1.RData")

```

#### Summarize and compare

First, compare computational time (in minutes) for each model:

```{r, echo = FALSE}
data.frame(
  Model = c("Paciorek and Schervish", "Risser and Calder"),
  MCMC_time = c(PacScher.tm[3]/60, RisserCalder.tm[3]/60)
)
```

Next, for the Paciorek and Schervish analysis: posterior summaries are not provided in the paper for the spatially-constant mean, spatial variance, and nugget variance, but we provide them here:

```{r, echo = FALSE}
data.frame(
  Parameter = c("Mean", "Spatial variance", "Nugget variance"),
  PosteriorMean = round(c(mean(postSamp_PacScher[,"beta"]), mean(postSamp_PacScher[,"alpha"]),
                    mean(postSamp_PacScher[,"delta"])), 3),
   PosteriorSD = round(c(sd(postSamp_PacScher[,"beta"]), sd(postSamp_PacScher[,"alpha"]),
                   sd(postSamp_PacScher[,"delta"])), 3)
)

```

The anisotropy process is somewhat more difficult to summarize, given the high dimensionality of the parameters involved. Spatial maps of the elements of $\Sigma(\cdot)$ are here:

```{r, echo = FALSE, fig.height=6, fig.width=10, warning = FALSE}
grid.arrange(
  plot_spat(coords, round(colMeans(log(postSamp_PacScher[,1:217])),1), pt.size = 1.25, shp = 16, brk_rd = 1,
            ttle.txt = "Posterior mean: log(Sigma11)", 
            col.pal = viridis_pal(option = "viridis")(9)),
  plot_spat(coords, round(colMeans(log(postSamp_PacScher[,435:651])),1), pt.size = 1.25, shp = 16, brk_rd = 1,
            ttle.txt = "Posterior mean: log(Sigma22)", 
            col.pal = viridis_pal(option = "viridis")(9)),
  plot_spat(coords, colMeans(postSamp_PacScher[,218:434]), pt.size = 1.25, shp = 16, brk_rd = 3,
            ttle.txt = "Posterior mean: Sigma12", col.lim = c(-0.01, 0.01),
            col.pal = brewer.pal(9,"RdBu")),
  nrow = 2
)
```

Alternatively, we can summarize the matrix process $\Sigma(\cdot)$ via the ellipse corresponding to the constant probability contour of a bivariate Gaussian distribution with covariance $\Sigma(\cdot)$ (this is similar to the plot shown in Figure 4 of Paciorek and Schervish, 2006). The following ellipses are calculate based on the posterior mean of the spatially-varying components of $\Sigma(\cdot)$:

```{r, echo = FALSE}
# Look at ellipses
Sigma_postMed <- matrix(apply(postSamp_PacScher[,1:651], 2, median), ncol = 3, byrow = FALSE)
# Closest to knot locs
x_min <- min(coords[,1])
x_max <- max(coords[,1])
y_min <- min(coords[,2])
y_max <- max(coords[,2])
N_knots <- 36
knot_coords <- expand.grid(
  lon = seq(from = x_min + 0.5 * (x_max - x_min)/floor(sqrt(N_knots)), 
            to = x_max - 0.5 * (x_max - x_min)/floor(sqrt(N_knots)), 
            length = floor(sqrt(N_knots))),
  lat = seq(from = y_min + 0.5 * (y_max - y_min)/floor(sqrt(N_knots)), 
            to = y_max - 0.5 * (y_max - y_min)/floor(sqrt(N_knots)), 
            length = floor(sqrt(N_knots)))
)
Sigma_cross_dist2 <- mahalanobis.dist(coords, knot_coords, diag(2))

coord_knot_loc <- apply(Sigma_cross_dist2, 2, which.min)
Sigma_use <- Sigma_postMed[coord_knot_loc,]
coords_use <- coords[coord_knot_loc,]
Sigma_array <- array(NA, dim=c(2,2,N_knots))
for(i in 1:N_knots){
  Sigma_array[1,1,i] <- Sigma_use[i,1]
  Sigma_array[1,2,i] <- Sigma_use[i,2]
  Sigma_array[2,1,i] <- Sigma_use[i,2]
  Sigma_array[2,2,i] <- Sigma_use[i,3]
}

plotEllip(coords_use, Sigma_array)
US(add=T, col = "gray")
```

Similar to Figure 4 in Paciorek and Schervish (2006), note that the ellipses (and hence range of dependence) is much smaller in the center of the domain -- where there is highly diverse topography -- but large in the eastern part of Colorado where the topography is flat, and also somewhat larger in the far western part of the state where the topography is much less heterogeneous.

Next, we can directly compare posterior means and credible intervals from the analysis here with the analysis done in Risser and Calder (2015).

```{r, echo = FALSE}
# Environmetrics results
oldResults <- data.frame(
	Parameter = c("beta0", "beta1", "beta2", "beta3", "sigmasq0", "alpha1", "alpha2", "alpha3",
				        "gamma11", "gamma12", "gamma13", "gamma14", "gamma21", "gamma22", "gamma23", "gamma24",
				        "psi11", "psi22", "psi12", "tausq" ),
	PostMean = c(6.308, 0.477, 0.053, 0.074, 0.163, 0.147, 0.101, -0.124,
				       -0.292, 1.770, -0.752, 0.571, -0.312, -0.869, 0.876, 0.134,
				       0.602, 1.240, -0.153, 0.010),
	CI_lb = c(6.155, 0.384, 0.013, 0.022, 0.115, -0.127, -0.089, -0.391,
	          -1.429, 0.420, -1.723, -0.394, -1.278, -1.981, -0.687, -1.053,
	          0.262, 0.535, -0.737, 0.006),
	CI_ub = c(6.488, 0.575, 0.091, 0.124, 0.227, 0.410, 0.308, 0.126, 
	          0.756, 3.310, 0.200, 1.543, 0.596, 0.063, 2.034, 1.952,
	          1.215, 2.671, 0.354, 0.016)
)

# Results for the current analysis
# Condition on gamma12 being positive
sampUse <- postSamp_RisserCalder[postSamp_RisserCalder[,"gamma1[2]"] >= 0,]
sampUse[,"alpha[1]"] <- exp(sampUse[,"alpha[1]"])^2 # Convert alpha[1] to sigmasq0
sampUse[,"rho"] <- sampUse[,"rho"]*sqrt(sampUse[,"psi11"]*sampUse[,"psi22"]) # Convert rho to psi12

newOrd <- c(5:8,1:4,10:20,9)
newResults <- data.frame(
	Parameter = c("beta0", "beta1", "beta2", "beta3", "sigmasq0", "alpha1", "alpha2", "alpha3",
	              "gamma11", "gamma12", "gamma13", "gamma14", "gamma21", "gamma22", "gamma23", "gamma24",
				        "psi11", "psi22", "psi12", "tausq" ),
	PostMean = apply(sampUse, 2, mean)[newOrd],
	CI_lb = apply(sampUse, 2, function(x){quantile(x, prob = 0.025)})[newOrd],
	CI_ub = apply(sampUse, 2, function(x){quantile(x, prob = 0.975)})[newOrd]
)

allResults <- rbind(oldResults, newResults)
allResults$Type <- ordered(rep(c("Risser/Calder","BayesNSGP"), each = 20), levels = c("Risser/Calder","BayesNSGP"))
rownames(allResults) <- NULL

ggplot(allResults, aes(x = Parameter, y = PostMean, ymin = CI_lb, ymax = CI_ub, color = Type)) +
	geom_pointrange(position = position_dodge(width = 0.2), size = 0.35) +
  scale_color_manual(values = c("red","blue")) +
  theme(axis.text.x = element_text(angle=45, hjust=1) )


```

Clearly, we are able to reproduce the posterior summaries of the original analysis.

\ 

\

 
