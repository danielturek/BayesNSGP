---
title: Application 2: water year precipitation over CONUS, 2018
author: Mark Risser
date: 8 May 2019
output: html_document
---

\   

```{r, message = FALSE, warning = FALSE}
library(nimble)
library(coda)
library(StatMatch)
nimbleOptions(verbose = FALSE)
library(BayesNSGP)

library(ggplot2)
library(RColorBrewer)
library(gridExtra)
library(viridis)

source("~/CASCADE_Projects/_PUBLISHED/gridded_precip/plots_paper/source_plot.R")

```

\   

### Introduction

Now, we attempt to analyze a larger data set consisting of measurements of the daily precipitation rate from $n = 2311$ stations from the GHCN over the contiguous United States (CONUS) for the 2018 water year (October 1, 2017 to September 30, 2018). These stations were chosen as the subset of all GHCN stations (21269 total) that had no missing daily values over this time period. In this analysis we will compare the different likelihood methods (fullGP, NNGP, and SGV), since the size of this data set is still relatively reasonable for fitting a full Gaussian process model.

First, load the data to be used in both analyses and create the constants needed for the NIMBLE functionality:

```{r, message = FALSE}
# Load data =====================================
CONUSprecip <- read.csv("data/CONUS_WY2018.csv")

# Testing: use only a subsample
set.seed(1)
subsamp <- sort(sample(nrow(CONUSprecip), 1000))
CONUSprecip <- CONUSprecip[subsamp,]

coords <- as.matrix(CONUSprecip[,c("lcc_x", "lcc_y")])
z <- CONUSprecip$logPR
elevShift <- mean(CONUSprecip$Xelevation)
elevScale <- sd(CONUSprecip$Xelevation)
CONUSprecip$Zelevation <- (CONUSprecip$Xelevation - elevShift)/elevScale
CONUSprecip$indWest <- as.numeric(CONUSprecip$longitude < -100) 
Xmat <- unname(lm(logPR ~ Zelevation*indWest, x = TRUE, data = CONUSprecip)$x)
N <- nrow(CONUSprecip)

# Load prediction grid: elevation and slope =====
CONUS_predDF <- read.csv("data/CONUS_predGrid.csv")

# MCMC setup ====================================
niter <- 200
strt.kp <- 101
```

Take a quick look at the precipitation rates:

```{r, echo = FALSE, fig.height=6, fig.width=10, warning = FALSE}
plot_conus( df = CONUSprecip, color = CONUSprecip$PR, col.lim = c(0.4, 9), 
            col.type = "cont", scale.trans = "log",
            col.pal = viridis_pal(option = "viridis")(9)[9:1], plot.grid = FALSE,
            brk_rd = 1, shp = 16, pt.size = 1.5, barheight = 20, n_brks = 9,
            xlab = NULL, ylab = NULL, ttle.txt = "Precipitation rate, 2018 water year (mm/day)" )
```

For this analysis, we set out to allow each component (mean, nugget variance, spatial variance, and anisotropy process) of the model to vary linearly with elevation, with an interaction term that indicates whether the station is in the western United States (i.e., west of the 100$^\circ$W meridian). The purpose of the interaction is to allow a different relationship between elevation and the mean/covariance parameters for the mountain west, relative to the eastern United States. Specifically, we will use the componentwise regression approach for the anisotropy process. With four regression coefficients (intercept, elevation, a western US indicator, and the elevation/western US indicator interaction), this means we have $4 \times 6=24$ parameters to estimate (recall the anisotropy process involves three separate regression models).

#### (1) Full GP likelihood

```{r}
# Distance matrices and constants
constants <- list( 
  nu = 0.5, N = N,
  tau_HP1 = 10, p_tau = ncol(Xmat), X_tau = Xmat,
  sigma_HP1 = 10, p_sigma = ncol(Xmat), X_sigma = Xmat,
  Sigma_HP1 = 5, Sigma_HP5 = 100, p_Sigma = ncol(Xmat), X_Sigma = Xmat,
  mu_HP1 = 10, p_mu = ncol(Xmat), X_mu = Xmat )

# Setup
Rmodel <- nsgpModel(likelihood = "fullGP", constants = constants, 
                    coords = coords, z = z, tau_model = "logLinReg", 
                    sigma_model = "logLinReg", mu_model = "linReg", 
                    Sigma_model = "compReg")
conf <- configureMCMC(Rmodel)
conf$removeSamplers()
conf$addSampler(target = c("alpha[1]","alpha[2]","alpha[3]","alpha[4]"), type = "RW_block")
conf$addSampler(target = c("beta[1]","beta[2]","beta[3]","beta[4]"), type = "RW_block")
# conf$addSampler(target = c("alpha[1]","alpha[2]","alpha[3]","alpha[4]",
#                            "beta[1]","beta[2]","beta[3]","beta[4]"), type = "RW_block")
# conf$addSampler(target = c("delta[1]","delta[2]","delta[3]","delta[4]"), type = "RW_block")
# conf$addSampler(target = c("Sigma_coef1[1]","Sigma_coef1[2]","Sigma_coef1[3]","Sigma_coef1[4]"), 
#                 type = "RW_block")
# conf$addSampler(target = c("Sigma_coef2[1]","Sigma_coef2[2]","Sigma_coef2[3]","Sigma_coef2[4]"), 
#                 type = "RW_block")
conf$addSampler(target = c("Sigma_coef1[1]","Sigma_coef1[2]","Sigma_coef1[3]","Sigma_coef1[4]",
                           "Sigma_coef2[1]","Sigma_coef2[2]","Sigma_coef2[3]","Sigma_coef2[4]"), 
                type = "RW_block")
conf$addSampler(target = c("Sigma_coef3[1]","Sigma_coef3[2]","Sigma_coef3[3]","Sigma_coef3[4]"),
                type = "RW_block")
conf$getSamplers()

# Build/run
Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
prt <- proc.time()
samples_fullGP <- runMCMC(Cmcmc, niter = 5000, nburnin = 0)
time_fullGP <- proc.time() - prt


par(ask = TRUE)
for(h in 1:ncol(samples_fullGP)) plot(samples_fullGP[,h], type = "l", main = colnames(samples_fullGP)[h])
par(ask = FALSE)


# save(samples_fullGP, file = "samples_fullGP.RData")

```

#### (2) SGV likelihood

```{r}
k <- 15

# SGV
SGV_setup <- sgvSetup(locs = coords, k = k, seed = 31)
nID_SGV <- SGV_setup$nID_ord
dist_SGV <- nsDist3d(coords[SGV_setup$ord,], nID_SGV)
constants_SGV <- list( dist1_3d = dist_SGV$dist1_3d, dist2_3d = dist_SGV$dist2_3d, 
                       dist12_3d = dist_SGV$dist12_3d, num_NZ = 3*N + k*N - (k*(k+1)/2),
                       nu = 0.5, N = N, k = k, nID = nID_SGV, cond_on_y = SGV_setup$condition_on_y_ord,
                       tau_HP1 = 10, p_tau = ncol(Xmat), X_tau = Xmat,
                       sigma_HP1 = 10, p_sigma = ncol(Xmat), X_sigma = Xmat,
                       Sigma_HP1 = 5, p_Sigma = ncol(Xmat), X_Sigma = Xmat,
                       mu_HP1 = 10, p_mu = ncol(Xmat), X_mu = Xmat, d = 2 )

# Setup
Rmodel_SGV <- nsgpModel( likelihood = "SGV", constants = constants_SGV, z = z,
                            tau_model = "logLinReg", sigma_model = "logLinReg", 
                            mu_model = "linReg", Sigma_model = "compReg" )
compl_model_SGV <- compileNimble( Rmodel_SGV )
conf_model_SGV <- configureMCMC( Rmodel_SGV )
conf_model_SGV$removeSamplers()
conf_model_SGV$addSampler(target = c("alpha[1]","alpha[2]","alpha[3]","alpha[4]"), type = "RW_block")
conf_model_SGV$addSampler(target = c("delta[1]","delta[2]","delta[3]","delta[4]"), type = "RW_block")
conf_model_SGV$addSampler(target = c("beta[1]","beta[2]","beta[3]","beta[4]"), type = "RW_block")
conf_model_SGV$addSampler(target = c("Sigma_coef1[1]","Sigma_coef1[2]","Sigma_coef1[3]","Sigma_coef1[4]"), 
                             type = "RW_block")
conf_model_SGV$addSampler(target = c("Sigma_coef2[1]","Sigma_coef2[2]","Sigma_coef2[3]","Sigma_coef2[4]"), 
                             type = "RW_block")
conf_model_SGV$addSampler(target = c("Sigma_coef3[1]","Sigma_coef3[2]","Sigma_coef3[3]","Sigma_coef3[4]"), 
                             type = "RW_block")
conf_model_SGV$getSamplers()
nim_mcmc_SGV <- buildMCMC(conf_model_SGV)
nim_Cmcmc_SGV <- compileNimble(nim_mcmc_SGV, project = Rmodel_SGV)

# Run MCMC
prt <- proc.time()
nim_Cmcmc_SGV$run(niter)
SGV.tm <- proc.time() - prt
postSamp_SGV <- as.matrix(nim_Cmcmc_SGV$mvSamples)[strt.kp:niter,]


```



